# 実例

　条件分岐(if文)とループ(for文)におけるコンパイラの最適化を見ていきましょう。今回は未定義動作のためにアセンブリコード量を大きく減らせるような関数の最適化は扱いません。扱うコンパイラはGCC10.1、Clang10.0.0、MSVC19.24です。すべてC++2aでコンパイルしています。


## 条件分岐

　条件分岐のあるコードを適当に書いてみましょう。

```cpp
int f1(int a, int b) {           // A
    if(a == 0 || b == 0) {       // B
        return 0;                // C
    }
    if(a == 0 && b == 0) {       // D
        return -1;               // E
    }
    return 1;                    // F
}                                // G

```



### 最適化なしコンパイル

　さあコンパイルしてみましょう。一旦最適化なし(-O0)で、GCCでコンパイルしてみます。アセンブリは以下のようになります。

ソースコードが忠実にアセンブリに翻訳されていますね。一瞬、a == 0 が評価された段階で(b == 0 を評価する前に)、ジャンプしてしまうのはおかしいと感じるかもしれませんが、規格では論理演算子operator||とoperator&&は左の項がそれぞれtrue/falseと評価されたなら右の項は評価されないので、正しい挙動です。つまりこういうことです。

```asm
f1(int, int):
        pushq   %rbp                 # ベースポインタの値をスタックへ保存 (A)
        movq    %rsp, %rbp           # スタックポインタの値をベースポインタへ格納 (A)
        movl    %edi, -4(%rbp)       # 第一引数の値をスタックフレーム上のaへ保存 (A)
        movl    %esi, -8(%rbp)       # 第二引数の値をスタックフレーム上のbへ保存 (A)
        cmpl    $0, -4(%rbp)         # a == 0 か？ (B)
        je      .L2                  # もしそうなら.L2タグへジャンプ (B)
        cmpl    $0, -8(%rbp)         # b == 0 か？ (B)
        jne     .L3                  # もしそうでない.L3タグへジャンプ (B)
.L2:
        movl    $0, %eax             # 戻り値に0を格納 return 0 (C)
        jmp     .L4                  # .L4タグへジャンプ (C)
.L3:
        cmpl    $0, -4(%rbp)         # a == 0 か？ (D)
        jne     .L5                  # もしそうでないなら.L5へジャンプ (D)
        cmpl    $0, -8(%rbp)         # b == 0 か？ (D)
        jne     .L5                  # .L5タグへジャンプ (D)
        movl    $-1, %eax            # 戻り値を-1に (E)
        jmp     .L4                  # .L4タグへジャンプ (E)
.L5:
        movl    $1, %eax             # 戻り値を1に (F)
.L4:
        popq    %rbp                 # スタックへ保存したベースポインタの値を復帰 (G)
        ret                          # 呼び出し元へ復帰 (G)

```



### 最適化あり

　話が逸れましたが、元のコード(f1.cpp)に戻って、改めて最適化(-O2)をかけた状態でコンパイルしてみましょう。

```asm
f1(int, int):
        testl   %edi, %edi           # aとaで論理積を取る。a == 0 なら0、それ以外なら1になる (B)
        sete    %al                  # 上の結果を%eaxに代入(%alは%eaxの下位8bit分) (B?)
        testl   %esi, %esi           # bとbで論理積を取る。b == 0 なら0、それ以外なら1になる (B)
        sete    %dl                  # 上の結果を%edxに代入(%dlは%edxの下位8bit分) (B?)
        orl     %edx, %eax           # %eax || %edx を計算し%eaxへ入れる (C)
        xorl    $1, %eax             # 1と%eaxの排他的論理和をとって%eaxへ入れる (C, F)
        movzbl  %al, %eax            # %eax下位8bitを%eaxへコピー(上位24bitを0詰めするのが目的か？) (C, F)
        ret                          # 呼び出し元へ返る (G)

```

皆さん既にお気付きかもしれませんが、この関数では-1を返すことはありません。というのも a == 0 かつ b == 0 のときは、当然 a == 0 または b == 0 も満たしますから、関数は0を返します。

コード内のD, Eの部分の条件分岐は余分であるということです。一般に条件分岐はジャンプ命令を生み、これは比較的計算時間コストが大きいため、できれば余計な条件分岐は避けるべきです。

コンパイラは余計な分岐に気づいて、コードを削除してくれる。

このコードにはジャンプが一つもありません。

これはつまり全ての条件分岐を消し去ったことを意味しています。コードのD, Eの部分を消せると気付く人は多いかもしれませんが、Aの部分の条件分岐まで消せると分かった人は少ないのではないでしょうか。



## ループ

積算のコードを求めてみる。

```cpp
int sum0(int n) {
    int sum = 0;
    for (int i = 0;i < n; i++) {
        sum++;
    }
    return sum;
}

```

コンパイラしてみると。

余分なΣを削除している。

```asm
sum_i0(int):
        xorl    %eax, %eax
        testl   %edi, %edi
        cmovnsl %edi, %eax
        retq

```
