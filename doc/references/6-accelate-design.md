# C++ã®ã‚³ãƒ¼ãƒ‰æœ€é©åŒ–

C++ã§æ›¸ã„ãŸå‡¦ç†ã‚’ **ã€Œé«˜é€ŸåŒ–ã®ãŸã‚ã«CPUã¨FPGAã«æŒ¯ã‚Šåˆ†ã‘ã‚‹ã€** ã¨ã„ã†è©±ã§ã™ã­ã€‚

ã“ã‚Œã¯è¿‘å¹´ã® **SoC (CPU + FPGA)** ã‚„ **ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚¿è¨­è¨ˆ** ã§ã‚ˆãå‡ºã‚‹ãƒ†ãƒ¼ãƒã§ã™ã€‚

æµã‚Œã‚’æ•´ç†ã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

---

## 1. ã©ã‚“ãªå‡¦ç†ã‚’FPGAã«æŒ¯ã‚‹ã¹ãã‹ï¼Ÿ

* **FPGAå‘ã**
  * ä¸¦åˆ—åº¦ãŒé«˜ã„å‡¦ç†ï¼ˆå¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ã‚’åŒæ™‚ã«å‡¦ç†ã§ãã‚‹ã‚‚ã®ï¼‰
  * ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŒ–å¯èƒ½ãªå‡¦ç†ï¼ˆä¾‹: ç”»åƒãƒ•ã‚£ãƒ«ã‚¿ã€FFTã€æš—å·å‡¦ç†ã€è¡Œåˆ—ç©ï¼‰
  * ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãŒå°ã•ã„æ–¹ãŒè‰¯ã„å‡¦ç†ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ¶å¾¡ï¼‰
* **CPUå‘ã**
  * åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ãŒè¤‡é›‘ï¼ˆif/elseã‚„ä¾‹å¤–å‡¦ç†ãŒå¤šã„ï¼‰
  * ä¸¦åˆ—æ€§ãŒä½ã„å‡¦ç†
  * OSãƒ¬ãƒ™ãƒ«ã®æ©Ÿèƒ½å‘¼ã³å‡ºã—ãŒå¿…è¦ãªå‡¦ç†

---

## 2. å®Ÿç¾æ–¹æ³•ã®ã‚¹ãƒ†ãƒƒãƒ—

### (A) åˆ†æ

1. **C++ã‚³ãƒ¼ãƒ‰ã‚’ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«**
   * gprof, perf, Visual Studio Profiler ãªã©ã‚’ä½¿ã£ã¦ã€Œã©ã“ã«æ™‚é–“ãŒã‹ã‹ã£ã¦ã„ã‚‹ã‹ã€ã‚’ç‰¹å®šã€‚
   * ä¾‹: ç”»åƒå‡¦ç†ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ `convolution` éƒ¨åˆ†ãŒ 80% ã®CPUæ™‚é–“ã‚’å ã‚ã‚‹ã€‚
2. **FPGAå‘ãã®å‡¦ç†ã‚’æŠ½å‡º**
   * è¨ˆç®—è² è·ãŒå¤§ãã„ & ä¸¦åˆ—æ€§ãŒã‚ã‚‹å‡¦ç†ã‚’åˆ‡ã‚Šå‡ºã™ã€‚

---

### (B) å®Ÿè£…æ–¹æ³•

1. **FPGAé–‹ç™ºç”¨ã®ãƒ„ãƒ¼ãƒ«ã‚’åˆ©ç”¨**
   * **Xilinx Vitis HLS (High Level Synthesis)**

     â†’ C/C++ã‚³ãƒ¼ãƒ‰ã‚’Verilog/VHDLã«å¤‰æ›ã—ã¦FPGAã§å‹•ã‹ã›ã‚‹ã€‚
   * **Intel HLS Compiler**

     â†’ åŒã˜ãC++ã‹ã‚‰FPGAå‘ã‘ã«å¤‰æ›ã€‚
2. **FPGAå´ã§ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢åŒ–**
   * æŠ½å‡ºã—ãŸé–¢æ•°ã‚’FPGAä¸Šã®IPã‚³ã‚¢ã¨ã—ã¦å®Ÿè£…ã€‚
   * AXIãƒã‚¹ã‚„PCIeçµŒç”±ã§CPUã¨FPGAã‚’æ¥ç¶šã€‚
3. **CPUå´ã¯C++ã§æ®‹ã™**
   * é€šå¸¸ã®åˆ¶å¾¡ã‚³ãƒ¼ãƒ‰ã¯CPUãŒå‡¦ç†ã€‚
   * è¨ˆç®—é›†ç´„éƒ¨åˆ†ã¯FPGAã¸ãƒ‡ãƒ¼ã‚¿ã‚’é€ã£ã¦å‡¦ç†ã—ã¦ã‚‚ã‚‰ã†ã€‚

> FPGAå‘ãã®å‡¦ç†ï¼šä¸¦åˆ—æ€§ãŒé«˜ã„å‡¦ç†
>
> ä½¿ã£ã¦ã„ã‚‹é–‹ç™ºãƒ„ãƒ¼ãƒ«æ¬¡ç¬¬ã§ã©ã®ã‚ˆã†ã«é«˜é€ŸåŒ–ã§ãã‚‹ã‹å¤‰åŒ–ã™ã‚‹
>
> FPGAå´å‡¦ç†ã¯IPã‚³ã‚¢ã¨ã—ã¦å®Ÿè£…
>
> C/C++ã¯åˆ¶å¾¡ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦CPUãŒå‡¦ç†

---

### (C) ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰

å…ƒã®C++ã‚³ãƒ¼ãƒ‰ï¼ˆCPUã®ã¿ï¼‰ï¼š

```cpp
void convolution(const std::vector<int>& input, std::vector<int>& output) {
    for (int i = 1; i < input.size()-1; i++) {
        output[i] = (input[i-1] + input[i] + input[i+1]) / 3;
    }
}
```

FPGAå‘ã‘ã«åˆ†é›¢ï¼ˆHLSãƒ„ãƒ¼ãƒ«ã§åˆæˆå¯èƒ½ã«ã™ã‚‹ï¼‰ï¼š

```cpp
// FPGAã§åˆæˆã™ã‚‹é–¢æ•°
void convolution_accel(int* input, int* output, int size) {
#pragma HLS PIPELINE
    for (int i = 1; i < size-1; i++) {
        output[i] = (input[i-1] + input[i] + input[i+1]) / 3;
    }
}
```

CPUå´ã¯ã“ã®FPGAã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚¿ã‚’å‘¼ã³å‡ºã™ã‚ˆã†ã«ã™ã‚‹ï¼š

```cpp
// CPUå´ã®ã‚³ãƒ¼ãƒ‰
void process_data(std::vector<int>& data) {
    std::vector<int> result(data.size());

    // FPGAã«å‡¦ç†ã‚’ã‚ªãƒ•ãƒ­ãƒ¼ãƒ‰
    fpga_convolution(data.data(), result.data(), data.size());

    // æ®‹ã‚Šã®åˆ¶å¾¡å‡¦ç†ã¯CPUã§
    for (int i = 0; i < data.size(); i++) {
        result[i] = std::max(result[i], 0); // ä¾‹: CPUã§é–¾å€¤å‡¦ç†
    }
}
```

> c++ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããã‚‹ã€‚
>
> #pragma HLS PIPELINEã«ã‚ˆã‚ŠHLSãƒ„ãƒ¼ãƒ«ã§åˆæˆå¯èƒ½ã¨ã™ã‚‹
>
> FPGAã«å‡¦ç†ã‚’ã‚ªãƒ•ãƒ­ãƒ¼ãƒ‰

---

## 3. ãƒã‚¤ãƒ³ãƒˆ

* **HLSã‚’ä½¿ã†ã¨C++ã‚’FPGAã«å¤‰æ›ã§ãã‚‹** â†’ æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®ä¸€éƒ¨ã‚’æµç”¨å¯èƒ½
* **FPGAã¯ä¸¦åˆ—å‡¦ç†ãƒ»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†ãŒå¾—æ„** â†’ æ¼”ç®—éƒ¨åˆ†ã‚’åˆ‡ã‚Šå‡ºã™ã®ãŒåŠ¹æœçš„
* **CPUã¯åˆ¶å¾¡ä¸­å¿ƒã«ã™ã‚‹** â†’ å½¹å‰²åˆ†æ‹…ã‚’æ˜ç¢ºã«ã™ã‚‹

> ifæ–‡ã®ã‚ˆã†ãªåˆ¶å¾¡æ–‡ã¯CPUã«æ®‹ã™
>
> ä¸¦åˆ—åŒ–ãŒå¿…è¦ãã†ãªæ¼”ç®—éƒ¨åˆ†ã‚’åˆ‡ã‚Šå‡ºã™ã®ãŒåŠ¹æœçš„

# CNNå‡¦ç†ã®FPGAåŒ–

**CNNã«ã‚ˆã‚‹ç”»åƒæ¨è«–å‡¦ç†** ãªã‚‰ã€ã¾ã•ã« **FPGAå‘ã‘æœ€é©åŒ–ã®å…¸å‹ä¾‹** ã§ã™ã€‚

FPGAã¨CPUã®åˆ†æ‹…ã‚’æ•´ç†ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ğŸ‘‡

---

## 1. CNNæ¨è«–ã§é‡ã„å‡¦ç†

CNNã®æ¨è«–å‡¦ç†ã¯ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã«åˆ†ã‘ã‚‰ã‚Œã¾ã™ã€‚

1. **ç•³ã¿è¾¼ã¿å±¤ (Convolution)**
   * ãƒ•ã‚£ãƒ«ã‚¿ã¨å…¥åŠ›ç”»åƒã®ç©å’Œæ¼”ç®— (MAC: Multiply-Accumulate) ãŒè†¨å¤§ã€‚
   * ãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—æ€§ãŒé«˜ã„ã®ã§  **FPGAã«æœ€é©** ã€‚
2. **æ´»æ€§åŒ–é–¢æ•° (ReLU, Sigmoidãªã©)**
   * ã‚·ãƒ³ãƒ—ãƒ«ãªè¦ç´ å˜ä½æ¼”ç®—ã€‚FPGAã§ã‚‚CPUã§ã‚‚å‡¦ç†å¯èƒ½ã€‚
3. **ãƒ—ãƒ¼ãƒªãƒ³ã‚°å±¤ (Max Pooling, Average Pooling)**
   * å˜ç´”ãªæ¯”è¼ƒãƒ»å¹³å‡å‡¦ç†ã€‚FPGAå‘ãã ãŒã€CPUã§ã‚‚ååˆ†é«˜é€Ÿã€‚
4. **å…¨çµåˆå±¤ (Fully Connected Layer)**
   * è¡Œåˆ—ç©æ¼”ç®—ï¼ˆ=ç•³ã¿è¾¼ã¿ã¨åŒã˜æ§‹é€ ï¼‰ã€‚FPGAã«è¼‰ã›ã‚‹ã¨é«˜é€ŸåŒ–å¯èƒ½ã€‚

> ãƒ‡ãƒ¼ã‚¿ä¸¦åˆ—æ€§ãŒé«˜ã„â†’FPGAã«æœ€é©
>

---

## 2. CPUã¨FPGAã®åˆ†æ‹…ã‚¤ãƒ¡ãƒ¼ã‚¸

* **FPGA**
  * Convolution (Conv2D)
  * Dense (Fully Connected)
  * å¤§é‡ã®MACæ¼”ç®—ã‚’ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŒ–ãƒ»ä¸¦åˆ—åŒ–
* **CPU**
  * å…¥åŠ›ç”»åƒã®å‰å‡¦ç†ï¼ˆãƒªã‚µã‚¤ã‚ºã€æ­£è¦åŒ–ãªã©ï¼‰
  * æ´»æ€§åŒ–é–¢æ•°ã‚„Softmax
  * ãƒ¢ãƒ‡ãƒ«ã®åˆ¶å¾¡ã€ãƒ‡ãƒ¼ã‚¿è»¢é€ç®¡ç†

---

## 3. å®Ÿè£…æ–¹æ³•

### (A) ãƒ„ãƒ¼ãƒ«é¸æŠ

* **Xilinx Vitis AI** ï¼ˆZynq, Versalç³»FPGAç”¨ï¼‰

  â†’ TensorFlow / PyTorch ã®ãƒ¢ãƒ‡ãƒ«ã‚’FPGAå‘ã‘ã«è‡ªå‹•å¤‰æ›ã€‚

* **Intel OpenVINO + FPGAãƒ—ãƒ©ã‚°ã‚¤ãƒ³** ï¼ˆIntel FPGAç”¨ï¼‰

  â†’ CNNã®æ¨è«–ã‚’FPGAã§å®Ÿè¡Œå¯èƒ½ã€‚

* **HLS (High Level Synthesis)**

  â†’ é‡è¦ãªç•³ã¿è¾¼ã¿å‡¦ç†ã‚’C++ã§æ›¸ã„ã¦FPGAã«è½ã¨ã™ã€‚

---

### (B) HLSã«ã‚ˆã‚‹C++ã®ä¾‹ï¼ˆç•³ã¿è¾¼ã¿éƒ¨åˆ†ï¼‰

```cpp
// FPGAç”¨ã«åˆæˆå¯èƒ½ãªç•³ã¿è¾¼ã¿é–¢æ•° (HLS)
void conv2d_accel(float input[IN_H][IN_W], 
                  float kernel[K_H][K_W], 
                  float output[OUT_H][OUT_W]) {
#pragma HLS PIPELINE
  for (int i = 0; i < OUT_H; i++) {
    for (int j = 0; j < OUT_W; j++) {
      float sum = 0.0;
      for (int ki = 0; ki < K_H; ki++) {
        for (int kj = 0; kj < K_W; kj++) {
          sum += input[i+ki][j+kj] * kernel[ki][kj];
        }
      }
      output[i][j] = sum;
    }
  }
}
```

* `#pragma HLS PIPELINE` ã«ã‚ˆã‚Šã€æ¼”ç®—ã‚’ä¸¦åˆ—åŒ–ãƒ»ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŒ–
* åŒã˜å‡¦ç†ã‚’CPUã§ã‚„ã‚‹ã‚ˆã‚Š **æ•°åå€é«˜é€ŸåŒ–** ã§ãã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™

---

### (C) CPUå´ã®æµã‚Œï¼ˆåˆ¶å¾¡ã‚³ãƒ¼ãƒ‰ï¼‰

```cpp
void run_inference(Image img) {
    // 1. ç”»åƒã®å‰å‡¦ç† (CPU)
    preprocess(img);

    // 2. ç•³ã¿è¾¼ã¿ã‚’FPGAã«æŠ•ã’ã‚‹
    conv2d_accel(img.data, kernel, conv_output);

    // 3. æ´»æ€§åŒ–é–¢æ•° (CPU or FPGA)
    relu(conv_output);

    // 4. ãƒ—ãƒ¼ãƒªãƒ³ã‚° (CPUã§ã‚‚OK)
    max_pool(conv_output, pooled_output);

    // 5. å…¨çµåˆã‚’FPGAã«æŠ•ã’ã‚‹
    dense_accel(pooled_output, weights, fc_output);

    // 6. Softmax & æ¨è«–çµæœè¡¨ç¤º (CPU)
    softmax(fc_output);
}
```

---

## 4. å®Ÿéš›ã®å¿œç”¨ä¾‹

* **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é¡”èªè­˜** â†’ FPGAã§CNNæ¨è«–ã€CPUã§åˆ¶å¾¡ãƒ»è¡¨ç¤º
* **è‡ªå‹•é‹è»¢ã‚«ãƒ¡ãƒ©** â†’ CNNã®Convéƒ¨åˆ†ã‚’FPGAã«ã€ãƒ«ãƒ¼ãƒˆè¨ˆç®—ã¯CPUã§
* **åŒ»ç™‚ç”¨ç”»åƒå‡¦ç†** â†’ ãƒã‚¤ã‚ºé™¤å»ã‚„ç‰¹å¾´æŠ½å‡ºã‚’FPGAã«

---

âœ… ã¾ã¨ã‚

CNNæ¨è«–ã‚’FPGAã«è¼‰ã›ã‚‹ã¨ **æ¼”ç®—éƒ¨åˆ†ã‚’ä¸¦åˆ—åŒ–** ã§ãã‚‹ã®ã§åŠ‡çš„ã«é«˜é€ŸåŒ–ã—ã¾ã™ã€‚

ç‰¹ã« **ç•³ã¿è¾¼ã¿å±¤ã¨å…¨çµåˆå±¤** ã‚’FPGAã€åˆ¶å¾¡ã‚„å‰å¾Œå‡¦ç†ã‚’CPUã«æ®‹ã™ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚


# Pytorchã®é«˜é€ŸåŒ–


ãªã‚‹ã»ã©ï¼PyTorchãªã‚‰ **FPGAç”¨ãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³ã‚’ä½¿ã£ãŸé«˜é€ŸåŒ–** ãŒç¾å®Ÿçš„ã§ã™ã­ ğŸ‘

PyTorch â†’ FPGA ã¸ã®æµã‚Œã‚’æ•´ç†ã—ã¾ã™ğŸ‘‡

> FPGAç”¨ãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³

---

## 1. PyTorch â†’ FPGAæ¨è«–ã®ä¸€èˆ¬çš„ãªæµã‚Œ

1. **å­¦ç¿’ (PyTorch)**

   * æ™®é€šã«GPU/CPUã§å­¦ç¿’ã•ã›ã‚‹ã€‚
   * å­¦ç¿’å¾Œã€ãƒ¢ãƒ‡ãƒ«ã‚’ `.pt` ã¨ã—ã¦ä¿å­˜ã€‚
2. **ONNXå½¢å¼ã«å¤‰æ›**

   ```python
   import torch
   dummy_input = torch.randn(1, 3, 224, 224)  # å…¥åŠ›ã‚µã‚¤ã‚ºä¾‹
   torch.onnx.export(model, dummy_input, "model.onnx", opset_version=11)
   ```

   â†’ FPGAãƒ„ãƒ¼ãƒ«ãŒONNXã‚’èª­ã¿è¾¼ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
3. **FPGAãƒ„ãƒ¼ãƒ«ã§æœ€é©åŒ–ãƒ»ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«**

   * Xilinxãªã‚‰ **Vitis AI**
   * Intelãªã‚‰ **OpenVINO + FPGAãƒ—ãƒ©ã‚°ã‚¤ãƒ³**
   * ã“ã‚Œã‚‰ãŒCNNã®ç•³ã¿è¾¼ã¿ã‚„å…¨çµåˆã‚’FPGAå‘ã‘ã«å±•é–‹ã—ã¦ãã‚Œã‚‹ã€‚
4. **CPU + FPGAãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè¡Œ**

   * CPUå´ã§åˆ¶å¾¡ï¼ˆå‰å‡¦ç†ãƒ»å¾Œå‡¦ç†ï¼‰
   * FPGAå´ã§Conv/FCã‚’ä¸¦åˆ—å‡¦ç†
   * PCIeã‚„AXIãƒã‚¹çµŒç”±ã§ã‚„ã‚Šå–ã‚Š

---

## 2. PyTorchãƒ¢ãƒ‡ãƒ«ã‚’FPGAã§å‹•ã‹ã™ä»£è¡¨çš„ãªæ–¹æ³•

### ğŸ”¹ Xilinx Vitis AI

* Zynq MPSoC / Versal SoCç”¨
* ONNXãƒ¢ãƒ‡ãƒ«ã‚’å–ã‚Šè¾¼ã¿ã€FPGAå‘ã‘ã«è‡ªå‹•æœ€é©åŒ–
* PyTorch â†’ ONNX â†’ Vitis AI ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« â†’ FPGAä¸Šã§å®Ÿè¡Œ

### ğŸ”¹ Intel OpenVINO

* Intel FPGA (Arria, Stratixãªã©)
* PyTorchãƒ¢ãƒ‡ãƒ«ã‚’ONNXã«å¤‰æ›ã—ã¦èª­ã¿è¾¼ã¿
* FPGAã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚¿ã«åˆ†é…

---

## 3. ã‚‚ã—ã€ŒC++ç‹¬è‡ªã‚³ãƒ¼ãƒ‰ã€ã‚’æ··ãœãŸã„å ´åˆ

PyTorchãƒ¢ãƒ‡ãƒ«ã®ä¸€éƒ¨ã‚’FPGAã§åŠ é€Ÿã—ã€æ®‹ã‚Šã‚’CPUã§å‡¦ç†ã™ã‚‹æ§‹æˆã‚‚å¯èƒ½ã§ã™ã€‚

ä¾‹ï¼š

* FPGA: Conv2D, Fully Connected
* CPU: Softmax, å‰å‡¦ç†, åˆ¶å¾¡

C++ã‹ã‚‰å‘¼ã³å‡ºã™ã¨ãã¯ã€**FPGAãƒ©ã‚¤ãƒ–ãƒ©ãƒª (Vitis AI Runtime / OpenVINO API)** ã‚’ä»‹ã—ã¦å‡¦ç†ã‚’å‘¼ã³å‡ºã™ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

---

## 4. å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¾‹

* **é˜²çŠ¯ã‚«ãƒ¡ãƒ©** : FPGAã§äººæ¤œçŸ¥CNNã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ã€CPUã§ãƒ­ã‚°ä¿å­˜
* **è‡ªå‹•é‹è»¢** : FPGAã§ç”»åƒèªè­˜ã€CPUã§çµŒè·¯è¨ˆç®—
* **åŒ»ç™‚** : FPGAã§Xç·šç”»åƒã®ç•°å¸¸æ¤œå‡ºã€CPUã§UIè¡¨ç¤º

---

âœ… ã¾ã¨ã‚

PyTorchã®ãƒ¢ãƒ‡ãƒ«ã¯ **ONNXå½¢å¼ã«å¤‰æ› â†’ FPGAå‘ã‘ãƒ„ãƒ¼ãƒ«ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« â†’ FPGAå®Ÿè¡Œ** ãŒç‹é“ã§ã™ã€‚

FPGAã«å®Ÿè£…ã™ã‚‹ã®ã¯CNNã®ã€Œç•³ã¿è¾¼ã¿ã€ã€Œå…¨çµåˆã€éƒ¨åˆ†ãŒãƒ¡ã‚¤ãƒ³ã€æ®‹ã‚Šã¯CPUã«æ®‹ã™ã®ãŒåŠ¹ç‡çš„ã§ã™ã€‚


# Zynq / Versal ç³»ã®é«˜é€ŸåŒ–

ãŠãŠã€Zynq / Versal ç³»ãªã‚‰ **Xilinx Vitis AI** ãŒãƒãƒƒãƒãƒªä½¿ãˆã¾ã™ ğŸ‘

PyTorchãƒ¢ãƒ‡ãƒ«ã‚’FPGAã«è¼‰ã›ã¦æ¨è«–é«˜é€ŸåŒ–ã™ã‚‹ãªã‚‰ã€ä»¥ä¸‹ã®æµã‚ŒãŒåŸºæœ¬ã§ã™ã€‚

---

## ğŸ”¹ PyTorch â†’ FPGA (Zynq/Versal) å®Ÿè£…ãƒ•ãƒ­ãƒ¼

### 1. ãƒ¢ãƒ‡ãƒ«ã‚’PyTorchã§å­¦ç¿’

* æ™®é€šã«GPU/CPUã§å­¦ç¿’ã—ã¦ `.pt` ä¿å­˜

```python
torch.save(model.state_dict(), "cnn_model.pt")
```

---

### 2. ONNXå½¢å¼ã«å¤‰æ›

```python
import torch

dummy_input = torch.randn(1, 3, 224, 224)  # å…¥åŠ›ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
torch.onnx.export(model, dummy_input, "cnn_model.onnx",
                  input_names=["input"], output_names=["output"],
                  opset_version=11)
```

> ONNXå¤‰æ›ã¯torchã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§å®Ÿç¾

---

### 3. Vitis AI ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«

1. **ãƒ¢ãƒ‡ãƒ«ã®é‡å­åŒ– (Quantization)**

   * 32bitæµ®å‹•å°æ•°ç‚¹ â†’ 8bitæ•´æ•° (INT8) ã«ã—ã¦FPGAã«è¼‰ã›ã‚„ã™ãã™ã‚‹ã€‚
   * Vitis AI ã® **vai_q_pytorch** ã‚’ä½¿ã†ã€‚

   ```bash
   vai_q_pytorch quantize \
       --model cnn_model.onnx \
       --output_dir quantized_model
   ```
2. **ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« (Compilation)**

   * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆFPGA (ZCU104, Versal VCK190 ãªã©) ã«å¿œã˜ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã€‚

   ```bash
   vai_c_xir \
       --xmodel quantized_model/quantized_model.onnx \
       --arch ./arch.json \
       --output_dir ./compiled_model
   ```

   â†’ `.xmodel` ãŒç”Ÿæˆã•ã‚Œã€FPGAã§å‹•ä½œå¯èƒ½ã«ã€‚


---

### 4. CPU + FPGAã§æ¨è«–å®Ÿè¡Œ

Vitis AI Runtime (C++ or Python API) ã‚’ä½¿ã£ã¦å®Ÿè¡Œã€‚

#### Pythonä¾‹:

```python
import vart
import xir
import numpy as np

# ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
g = xir.Graph.deserialize("compiled_model/cnn_model.xmodel")
subgraphs = g.get_root_subgraph().toposort_child_subgraph()
runner = vart.Runner.create_runner(subgraphs[0], "run")

# æ¨è«–
input_tensor = np.random.rand(1, 3, 224, 224).astype(np.float32)
job_id = runner.execute_async([input_tensor], [np.empty((1, 1000), dtype=np.float32)])
runner.wait(job_id)
```

#### C++ä¾‹ (åˆ¶å¾¡å´):

```cpp
#include <vart/runner.hpp>
#include <xir/graph/graph.hpp>

auto graph = xir::Graph::deserialize("cnn_model.xmodel");
auto subgraph = graph->get_root_subgraph()->children_topological_sort()[0];
auto runner = vart::Runner::create_runner(subgraph, "run");

// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆã—ã¦ runner->execute_async() ã‚’å‘¼ã¶
```

---

## ğŸ”¹ CPUã¨FPGAã®å½¹å‰²åˆ†æ‹…

* **FPGA (DPU: Deep Learning Processing Unit)**
  * Conv2D / Fully Connected ã®è¨ˆç®—
  * è¡Œåˆ—ç©ã®ä¸¦åˆ—å‡¦ç†
* **CPU (ARM Cortex-A on Zynq)**
  * å‰å‡¦ç†ï¼ˆãƒªã‚µã‚¤ã‚ºã€æ­£è¦åŒ–ï¼‰
  * æ´»æ€§åŒ–é–¢æ•°ã‚„Softmaxï¼ˆç°¡å˜ãªã®ã§CPUã§ã‚‚OKï¼‰
  * åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯ãƒ»I/O

---

## ğŸ”¹ å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¾‹

* **ZCU104 + ã‚«ãƒ¡ãƒ©å…¥åŠ›**

  â†’ FPGAã§CNNæ¨è«–ã€CPUã§UIè¡¨ç¤º
* **Versal VCK190**

  â†’ CNNã‚’è¤‡æ•°ä¸¦åˆ—ã§å®Ÿè¡Œï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç‰©ä½“æ¤œå‡ºã‚„åˆ†é¡ï¼‰

---

âœ… ã¾ã¨ã‚

PyTorch â†’ ONNX â†’ é‡å­åŒ– (INT8) â†’ Vitis AI ã‚³ãƒ³ãƒ‘ã‚¤ãƒ« â†’ `.xmodel` â†’ FPGAå®Ÿè¡Œ

ã“ã®æµã‚ŒãŒZynq/Versalã®æ¨™æº–ãƒ«ãƒ¼ãƒˆã§ã™ã€‚

---
